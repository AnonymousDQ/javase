### 链表LinkedList介绍
- 链表是以节点的方式来存储,是链式存储
- 每个节点包含data域，next域
- next域指向下一个节点
- 链表的各个结点不一定是连续存储
- 链表分带头节点的链表和没有头结点的链表，根据实际的需求来确定。
#### 1、带头节点head的链表
- head节点作用：
- 不存放具体的数据
- 作用：就是表示单链表的头
#### 2、创建（添加）的思路
- 先创建一个head头结点，作用就是表示单链表的头
- 后面每添加一个节点，就直接加入到链表的最后
#### 3、遍历
- 通过一个临时变量来辅助遍历，帮助遍历整个链表
#### 4、按照编号顺序来添加节点
- 1、首先找到新添加的节点的位置，是通过temp辅助变量(指针),肯定通过变量搞定
- 2、newNode.next=temp.next（新节点先连接temp.next防止断链）
- 3、将temp.next=newNode(然后temp节点的next连到newNode)
#### 5、单链表删除节点
* 从单链表删除一个节点
* 思路：
* 1、head节点不能，还是需要一个临时变量temp，然后遍历先找到需要删除节点的前一个节点
* 2、说明我们在比较时，temp.next.no和需要删除节点的no进行比较
* 2、将temp节点的next指向temp.next.next；也就是temp.next=temp.next.next;
* 3、此时被删除的节点(temp.next)没有任何引用指向它，在java中就成为一个垃圾，就会被垃圾回收机制回收
#### 5、总结
### 二、双向链表
- 使用带head头的双向链表实现
#### 1、单向链表的缺点分析
- 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找
- 单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，
总是找到temp，利用temp是待删除的前一个节点
#### 2、分析双向链表的遍历，添加，修改，删除的思路
- 遍历和单链表一样，即可以向前，也可以向后查找
- 添加（默认添加到双向链表的最后），先找到双向链表的最后这个节点
然后让temp.next=newNode,newNode.pre=temp
- 修改思路和单链表的思路一样。
- 删除
因为是双向链表，所以我们可以实现自我删除某个节点，
直接找到要删除的这个节点，比如是temp
temp.pre=temp.next;temp.next.pre=temp.pre;